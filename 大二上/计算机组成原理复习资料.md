# 计算机组成原理复习资料

## 1. 浮点数舍入位的作用

### 保护位 (Guard Bit)
- 在浮点数计算中，在右边多保留的两位中的**首位**
- 作用：提高舍入精度

### 舍入位 (Round Bit)
- 在浮点数计算中，在右边多保留的两位中的**第二位**
- 作用：使浮点中间结果满足浮点格式，得到最近的数

### 粘贴位 (Sticky Bit)
- 同保护位和舍入位一样用于舍入的位
- 当舍入位右边有非零的数据时将其置1

## 2. 冯诺依曼理论的三个要点

1. **五大部件**：
   - 运算器
   - 存储器
   - 输入设备
   - 输出设备
   - 控制器

2. **采用二进制**

3. **存储程序原理**：
   - 程序和原始数据先存入存储器
   - 然后再启动计算机工作

## 3. C语言程序转换为可执行程序的4个步骤

1. **编译**：把高级语言编译为汇编语言
2. **汇编**：把汇编语言转化成机器语言
3. **链接**：将程序与库链接成一个可执行文件
4. **加载**：将可执行文件加载到主存中

## 4. 程序的局部性原理

### 时间局部性
- 某个数据项在被访问后，在短时间内可能被再次访问

### 空间局部性
- 某个数据项被访问后，其附近的数据项也可能被访问

## 5. 硬件设计的三个基本原则

1. 简单源于规整
2. 越小越快
3. 优秀的设计需要适宜的折中方案

## 6. 缩短CPU时间的方法

- CPU时间 = 指令数 × CPI × 时钟周期
- 减少时钟周期
- 减小CPI
- 减少指令数
- 权衡时钟频率和时钟周期数

## 9. 乘除法器原理及除法执行过程

### 乘法器原理图
略

### 除法器原理图
略

### 除法的执行过程
**步骤一**：余数寄存器左移一位
**步骤二**：余数寄存器高32位减去除数寄存器中的数
**步骤三**：
- 若相减后余数寄存器中的最高位为0，则上商到余数寄存器最低位为1
- 若相减后余数寄存器中的最高位为1，上商到余数寄存器最低位为0

## 10. MIPS中获取32位立即数的方法

1. 利用Lui将16位立即数置入高16位
2. 利用Ori将低16位立即数置入低16位
3. 得到32位立即数

## 11. 控制冒险的三种解决方法

### 1）假定分支不发生
- 执行分支指令时，假设分支不发生，继续执行顺序的指令流
- 如果分支发生，就丢弃已经读取并译码的指令，并按分支目标继续执行
- 如果分支不发生的可能性是50%，同时丢弃的代价很小，那么这种优化方法可以将控制冒险的代价减半

### 2）缩短分支延迟
- 为了将分支决策提前，需要提前两个动作：计算分支目标地址和判断分支条件
- 分支目标地址计算从EX级移到ID级
- 判断分支条件从EX级移到ID级，需要额外的旁路和冒险检测硬件

### 3）动态分支预测
- 通过查找指令的地址观察上一次执行该指令时分支是否发生
- 如果上次执行时分支发生，就从上次分支发生的地方开始取新的指令

## 13. I型指令为什么没选择包括两个立即数的格式

1. **设计原则**：简单源于规整，优秀的设计需要适宜的折中方案。为了保持指令格式的一致性，MIPS指令集中没有选择包括两个立即数的格式。
2. **寻址范围**：两个立即数会导致寻址范围减小，影响程序执行。

## 14. 乘法器硬件结构及算法步骤

### 乘法器硬件结构图
图略

### 算法步骤
**步骤一**：
- 若乘数最低位为0，无操作
- 若乘数最低位为1，将被乘数加到积寄存器高32位

**步骤二**：积寄存器右移

**步骤三**：重复步骤一、步骤二直到积寄存器中64位全为积

## 16. 计算机系统结构8个伟大思想

1. 面向摩尔定律的设计
   - 示例：芯片设计要依据完成时的工业水平

2. 使用抽象简化设计
   - 示例：使用高级程序语言编程时可以不用过多考虑底层的机器指令如何实现功能

3. 加速大概率事件
   - 示例：采用静态分支预测，即假定分支发生或不发生的策略解决控制冒险，加速执行

4. 通过并行提高性能
   - 示例：通过并行树乘法器加快乘法运算；采用多处理器提高CPU性能

5. 通过流水线提高性能
   - 示例：多周期指令通过流水线的实现方式加速，提高执行性能

6. 通过预测提高性能
   - 示例：通过动态分支预测来减少控制冒险可能造成的阻塞，提高执行性能

7. 存储器层次
   - 示例：速度最快、容量最小、每位价格最贵的在顶层

8. 通过冗余提高可靠性
   - 示例：通过增加硬件支持解决流水线中的结构冒险

## 17. 存储器层次结构中处理写操作的方法

### Cache与主存
可采用写回和写直达
- **写直达**：替换方法简单，但需要写缓冲区
- **写回法**：需要保存更多的状态

### 主存与外部存储器
- **只能使用**：写回机制
- **原因**：磁盘的写延迟较长

## 18. 数组访问的局部性分析

```c
for(i=0; i<8; i++)
    for(j=0; j<8000; j++)
        a[i][j] = b[i][0] + a[i][j];
```

### 时间局部性
- 数组变量`b[i][0]`具有时间局部性
- 如果某个数据项被访问，那么在不久的将来它可能再次被访问

### 空间局部性
- `a[i][j]`被访问后，与其地址相邻的`a[i][j+1]`很快也被访问
- 如果某个数据项被访问，与它地址相邻的数据项很快可能也将被访问

## 20. MIPS指令集的三项设计原则

1. **简单源于规整**：
   - MIPS的指令大体分为R型和I型，具有整齐的统一结构

2. **越小越快**：
   - MIPS中只有32个寄存器

3. **优秀的设计需要适宜的折中方案**：
   - 保持所有的指令长度相同，但不同类型的指令采用不同的指令格式

## 21. 旁路解决数据冒险的原理

### 工作原理
- 通过转发，直接送到需要用到该数据的地方解决冒险

### 局限性
- **不能**解决所有的数据冒险
- **示例**：lw指令的目的寄存器是下一条指令add的rs或rt寄存器，此时无法通过转发解决数据冒险

## 22. Cache映射方式的比较

### 共同点
- 直接相联映射、组相联映射、全相联映射的共同点是**主存和cache都是分成同样大小的存储区块**

### 关系
- 组相联映射是直接相连映射和全相联映射的结合
- 若cache只有一组则为**全相联映射**
- 若一组中只有一块则为**直接相联映射**

## 23. MIPS中$ZERO寄存器的作用和意义

1. 可以用来得到立即数
   ```mips
   add $t0 $ZERO 12
   ```

2. 利用and指令将寄存器置零
   ```mips
   and $t1 $t1 $ZERO
   ```

## 24. CPU时间与指令数的关系

### 说法
- "执行指令最多的处理器需要更多的CPU时间" - **错误**

### 解释
- CPU时间 = 指令数 × CPI × 时钟周期
- 执行指令数多的处理器可能有较小的CPI和时钟周期
- **示例**：CICS与RICS，RICS执行指令更多，但是RICS执行速度可能更快

## 25. MIPS寻址方式

1. 立即数寻址
2. 寄存器寻址
3. 基址寻址
4. PC相对寻址
5. 伪直接寻址

## 26. 流水线冒险类型及解决方法

### 数据冒险
- **解决方法**：利用旁路转发，阻塞

### 控制冒险
- **解决方法**：
  1. 假定分支不发生
  2. 缩短分支的延迟
  3. 动态分支预测

## 27. MIPS J指令计算示例

### 条件
- 当前PC的高8位是：0000 1111
- 执行指令：J 2FFFFFE

### PC值
- **结果**：PC = 0x0BFFFFF8

### 原因
- J指令会把26位立即数左移两位，用00补齐
- 再用PC高四位进行补齐

## 28. 8位数快速乘法器设计
略

### 设计思路
1. 乘数放在乘积寄存器的后8位
2. 取最后一位：
   - 如果是1：令乘积寄存器高八位与被乘数相加
   - 如果是0：不变
3. 将乘积寄存器整体右移

## 29. TLB、页表、Cache访问组合分析

| TLB | 页表 | Cache | 可能发生吗？ | 说明 |
|-----|------|-------|-------------|------|
| 命中 | 命中 | 缺失 | 可能 | 页远大于块的大小，可能出现页命中了但是块未命中 |
| 缺失 | 命中 | 命中 | 可能 | 该页可能是第一次出现，未进入TLB中 |
| 缺失 | 命中 | 缺失 | 可能 | 结合前两种情况 |
| 缺失 | 缺失 | 缺失 | 可能 | 如果页未命中那么就会出现三个都未命中的情况 |
| 命中 | 缺失 | 缺失 | 不可能 | TLB是页表的子集 |
| 命中 | 缺失 | 命中 | 不可能 | TLB是页表的子集 |
| 缺失 | 缺失 | 命中 | 不可能 | 页未命中，块不可能命中 |
